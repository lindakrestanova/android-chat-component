# Firestore docs

### **The structure of the data on Firestore**

The overall structure of the Firestore database is built so that it's scalable and usable for multi-user chat as well requiring as few concurrently open connections as possible taking into account the querying restrictions of the client SDKs.

There are two top level collections in Firestore:
* Conversations
* Users

#### Conversations

The `conversations` is the top level collection in firestore


`conversations`
* `conversation_id` - identifier of each document (generated by firestore e.g. DJf19Wcn9n5arVMvSHPu)
* `last_message` - container for the minimum necessary info about the last message - the structure same as a standard message
    * ...
* `members` [] - an array of users who are members of this conversation
* `seen` - a list of users with the id and timestamp of the last message they read
    * `user123`
    	* `message_id` - identifier of the last message read by user `user123`
	* `timestamp` - timestamp of the last message read by user `user123`
* `messages` - as a subcollection of the conversation that can be paged and queried independently

#### Messages

The `messages` is subcollection of `conversations` in firestore
`messages`
* `message_id` - identifier of each document (generated by firstore e.g. DJf19Wcn9n5arVMvSHPu)
* `sender_id` - id of the user who sent the message
* `timestamp` - a timestamp of the message defined as a firestore Timestamp
* `message_type` - *text* | *image* - type of the message, more types to be added in future
* `data`
    * `message` - in case of a text message, the text of the message
    * `image` - in case of an image message, this object contains image data
        * `width` - integer defining the width of the image in pixels
        * `height` - integer defining the height of the image in pixels
        * `thumbnail` - thumbnail of the image (leave for v2 as we don't have any BE to process the images)
        * `original` - original size of the image

#### Users

The `users` is the top level collection in firestore
This collection can be used optionally but is in the default implementation of the SDK. However it should be relatively easy to swapable for a different external data source (e.g. REST API of the client). 
It contains the minimum necessary information about users that has to be shown for the chat. Ideally the client app won't have a long lasting connection opened to this collection, but will only refresh the users on a regular basis (usually in the matter of hours) - this is to be implemented by the client app.

`users`
* `id` - *String* user id independent of the auto-generated id for cases when these data has a source outside of Firestore
* `name` - name of the user
* `image_url` - image url of the user's profile picture

### **Code examples of basic queries**

##### To get all conversations for me as a user:

```
fun getFirestoreConversations() = firestoreDb //this is a reference to the firestore database that I'm connected to
        .collection("conversations") //here I want to look through collection of conversations
        .whereArrayContains("members", "83") //pick those that I'm a member of - here you pass your userId you get from our BE as a String
        .orderBy(FieldPath.of("last_message", "timestamp"), Query.Direction.DESCENDING) // you want to order from the newest to the oldest
        .addSnapshotListener { documentSnapshot, firebaseFirestoreException ->
            log("document snapshot fetched: $documentSnapshot") //you get a callback with the documentSnapshot that need to parse (deserialize), or you get an error
        }
```
        
##### To obtain the last 50 messages for a specific conversation, use a code similar to this:
//TODO here for adding a code snippet to fetch the messages as a subcollection
```
fun getFirestoreChatMessages() = firestoreDb //this is a reference to the firestore database that I'm connected to
        .collection("messages") //here I want to look through collection of messages
        .whereEqualTo("conversation_id", "xrrmeOJTkbvnb1TZwOy4") // you look for messages belonging to a specific bucket or 1to1 conversation id
        .limit(50) // limit messages to 50 in order not to load too much data unnecessarily - then we'll implement some paging 
        .orderBy("timestamp", Query.Direction.DESCENDING) // order from the newest
        .addSnapshotListener { documentSnapshot, firebaseFirestoreException ->
            log("document snapshot fetched: $documentSnapshot") // you get your messages here in the callback, need to parse the documentSnapshot
        }
```

##### To lazy load more messages after you load the 50

This is fairly easy, you just need to keep track of a timestamp of the oldest message that you loaded and then load additional 50 before that
//TODO here for adding a code snippet to fetch the messages as a subcollection
```
fun getFirestoreChatMessages() = firestoreDb //this is a reference to the firestore database that I'm connected to
        .collection("messages") //here I want to look through collection of messages
        .whereEqualTo("conversation_id", "xrrmeOJTkbvnb1TZwOy4") // you look for messages belonging to a specific bucket or 1to1 conversation id
        .orderBy("timestamp", Query.Direction.DESCENDING) // order from the newest
        .startAfter(timestamp)					//This is the timestamp of the oldest message and you want to load older messages from this. The startAfter() arguments need to be the type of the one provided in orderBy()
        .limit(50) // limit messages to 50 in order not to load too much data unnecessarily - then we'll implement some paging 
        .addSnapshotListener { documentSnapshot, firebaseFirestoreException ->
            log("document snapshot fetched: $documentSnapshot") // you get your messages here in the callback, need to parse the documentSnapshot
        }
```
        
##### Sending a message

The message sending works like this:
 - The conversation between two or more users has to be created beforehand and the client shouldn't be created by the client (TBD how this will work)
If a user sends a message, the client (Android/iOS) has to complete two writes to Firestore:
 1) creates a message with the respective data
 2) overwrites the last message in the conversation they just added to and changes the array of `seen` to contain only their userId

These two actions are executed atomically in a transaction (or so called batch write action)
//TODO here for adding a code snippet to create the message in the messages subcollection of the respective conversation
```
val writeBatch = firestoreDb.batch()
writeBatch.set(firestoreDb.collection("messages").document(), message)
writeBatch.update(firestoreDb.collection("conversations").document(conversationId), // id of the conversation to update
	"seen", arrayListOf(myUserId),						//pass in an array containing one element with my user id as a String
	"last_message.sender_id", "83",		                //this has to be my user id to follow security rules
	"last_message.message", "Hello world!",			    //text of the message
	"last_message.timestamp", 157987879878,		    //timestamp of the message in millis
	"last_message.message_type", "text")			//type of the message has to be set to "message"
	
//Commit the batch and set listeners for success and failure
batch.commit()						
		.addOnSuccessListener {}
		.addOnFailureListener {}
```

#### Setting a message as read
//TODO set the last message id for my user id when reading the last message
If a user sees a message, they add their userId to the list of `seen` 
This is the function I'm using to achieve that
```
firestoreDb.collection("conversations").document(conversationId).update("seen", FieldValue.arrayUnion(myUserId) //myUserId is a String
```

#### Loading user metadata

The data of the users will be downloaded periodically (by default not more often than once per hour) to keep it up to date and saved into a local database with a timestamp of the last update.
The connection to the user's collection will never be opened for longer periods and only for the one-time request.

`Code snippet TBD`
